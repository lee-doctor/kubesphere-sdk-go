/*
KubeSphere

KubeSphere OpenAPI

API version: v3.1.0
Contact: info@kubesphere.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DevOpsPipelineAPIService DevOpsPipelineAPI service
type DevOpsPipelineAPIService service

type ApiCheckCronRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	body *DevopsCronData
}

func (r ApiCheckCronRequest) Body(body DevopsCronData) ApiCheckCronRequest {
	r.body = &body
	return r
}

func (r ApiCheckCronRequest) Execute() (*DevopsCheckCronRes, *http.Response, error) {
	return r.ApiService.CheckCronExecute(r)
}

/*
CheckCron Check cron script compile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @return ApiCheckCronRequest
*/
func (a *DevOpsPipelineAPIService) CheckCron(ctx context.Context, devops string) ApiCheckCronRequest {
	return ApiCheckCronRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
	}
}

// Execute executes the request
//  @return DevopsCheckCronRes
func (a *DevOpsPipelineAPIService) CheckCronExecute(r ApiCheckCronRequest) (*DevopsCheckCronRes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsCheckCronRes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.CheckCron")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/checkCron"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckScriptCompileRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	value *string
}

// Pipeline script data
func (r ApiCheckScriptCompileRequest) Value(value string) ApiCheckScriptCompileRequest {
	r.value = &value
	return r
}

func (r ApiCheckScriptCompileRequest) Execute() (*DevopsCheckScript, *http.Response, error) {
	return r.ApiService.CheckScriptCompileExecute(r)
}

/*
CheckScriptCompile Check pipeline script compile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @return ApiCheckScriptCompileRequest
*/
func (a *DevOpsPipelineAPIService) CheckScriptCompile(ctx context.Context, devops string, pipeline string) ApiCheckScriptCompileRequest {
	return ApiCheckScriptCompileRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return DevopsCheckScript
func (a *DevOpsPipelineAPIService) CheckScriptCompileExecute(r ApiCheckScriptCompileRequest) (*DevopsCheckScript, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsCheckScript
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.CheckScriptCompile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/checkScriptCompile"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "value", r.value, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCredentialRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	credential string
}

func (r ApiDeleteCredentialRequest) Execute() ([]V1Secret, *http.Response, error) {
	return r.ApiService.DeleteCredentialExecute(r)
}

/*
DeleteCredential delete the credential of the specified devops for the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops project name
 @param credential credential name
 @return ApiDeleteCredentialRequest
*/
func (a *DevOpsPipelineAPIService) DeleteCredential(ctx context.Context, devops string, credential string) ApiDeleteCredentialRequest {
	return ApiDeleteCredentialRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		credential: credential,
	}
}

// Execute executes the request
//  @return []V1Secret
func (a *DevOpsPipelineAPIService) DeleteCredentialExecute(r ApiDeleteCredentialRequest) ([]V1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.DeleteCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha3/devops/{devops}/credentials/{credential}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credential"+"}", url.PathEscape(parameterValueToString(r.credential, "credential")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
}

func (r ApiDeletePipelineRequest) Execute() ([]V1alpha3Pipeline, *http.Response, error) {
	return r.ApiService.DeletePipelineExecute(r)
}

/*
DeletePipeline delete the pipeline of the specified devops for the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops project name
 @param pipeline pipeline name
 @return ApiDeletePipelineRequest
*/
func (a *DevOpsPipelineAPIService) DeletePipeline(ctx context.Context, devops string, pipeline string) ApiDeletePipelineRequest {
	return ApiDeletePipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return []V1alpha3Pipeline
func (a *DevOpsPipelineAPIService) DeletePipelineExecute(r ApiDeletePipelineRequest) ([]V1alpha3Pipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1alpha3Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.DeletePipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha3/devops/{devops}/pipelines/{pipeline}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactsRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
	start *string
	limit *string
}

// the item number that the search starts from.
func (r ApiGetArtifactsRequest) Start(start string) ApiGetArtifactsRequest {
	r.start = &start
	return r
}

// the limit item count of the search.
func (r ApiGetArtifactsRequest) Limit(limit string) ApiGetArtifactsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetArtifactsRequest) Execute() ([]DevopsArtifacts, *http.Response, error) {
	return r.ApiService.GetArtifactsExecute(r)
}

/*
GetArtifacts Get all artifacts in the specified pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetArtifactsRequest
*/
func (a *DevOpsPipelineAPIService) GetArtifacts(ctx context.Context, devops string, pipeline string, run string) ApiGetArtifactsRequest {
	return ApiGetArtifactsRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return []DevopsArtifacts
func (a *DevOpsPipelineAPIService) GetArtifactsExecute(r ApiGetArtifactsRequest) ([]DevopsArtifacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsArtifacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetArtifacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchArtifactsRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	start *string
	limit *string
}

// the item number that the search starts from.
func (r ApiGetBranchArtifactsRequest) Start(start string) ApiGetBranchArtifactsRequest {
	r.start = &start
	return r
}

// the limit item count of the search.
func (r ApiGetBranchArtifactsRequest) Limit(limit string) ApiGetBranchArtifactsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBranchArtifactsRequest) Execute() ([]DevopsArtifacts, *http.Response, error) {
	return r.ApiService.GetBranchArtifactsExecute(r)
}

/*
GetBranchArtifacts (MultiBranchesPipeline) Get all artifacts generated from the specified run of the pipeline branch.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetBranchArtifactsRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchArtifacts(ctx context.Context, devops string, pipeline string, branch string, run string) ApiGetBranchArtifactsRequest {
	return ApiGetBranchArtifactsRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return []DevopsArtifacts
func (a *DevOpsPipelineAPIService) GetBranchArtifactsExecute(r ApiGetBranchArtifactsRequest) ([]DevopsArtifacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsArtifacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchArtifacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchNodeStepsRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	node string
}

func (r ApiGetBranchNodeStepsRequest) Execute() ([]DevopsNodeSteps, *http.Response, error) {
	return r.ApiService.GetBranchNodeStepsExecute(r)
}

/*
GetBranchNodeSteps (MultiBranchesPipeline) Get all steps in the specified node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops the name of devops project
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @param node pipeline node ID, the stage in pipeline.
 @return ApiGetBranchNodeStepsRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchNodeSteps(ctx context.Context, devops string, pipeline string, branch string, run string, node string) ApiGetBranchNodeStepsRequest {
	return ApiGetBranchNodeStepsRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
		node: node,
	}
}

// Execute executes the request
//  @return []DevopsNodeSteps
func (a *DevOpsPipelineAPIService) GetBranchNodeStepsExecute(r ApiGetBranchNodeStepsRequest) ([]DevopsNodeSteps, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsNodeSteps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchNodeSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/nodes/{node}/steps"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchNodesDetailRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
}

func (r ApiGetBranchNodesDetailRequest) Execute() ([]DevopsNodesDetail, *http.Response, error) {
	return r.ApiService.GetBranchNodesDetailExecute(r)
}

/*
GetBranchNodesDetail (MultiBranchesPipeline) Get steps details in an activity node. For a node, the steps which is defined inside the node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetBranchNodesDetailRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchNodesDetail(ctx context.Context, devops string, pipeline string, branch string, run string) ApiGetBranchNodesDetailRequest {
	return ApiGetBranchNodesDetailRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return []DevopsNodesDetail
func (a *DevOpsPipelineAPIService) GetBranchNodesDetailExecute(r ApiGetBranchNodesDetailRequest) ([]DevopsNodesDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsNodesDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchNodesDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/nodesdetail"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
}

func (r ApiGetBranchPipelineRequest) Execute() (*DevopsBranchPipeline, *http.Response, error) {
	return r.ApiService.GetBranchPipelineExecute(r)
}

/*
GetBranchPipeline (MultiBranchesPipeline) Get the specified branch pipeline of the DevOps project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops the name of devops project
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch
 @return ApiGetBranchPipelineRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchPipeline(ctx context.Context, devops string, pipeline string, branch string) ApiGetBranchPipelineRequest {
	return ApiGetBranchPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
	}
}

// Execute executes the request
//  @return DevopsBranchPipeline
func (a *DevOpsPipelineAPIService) GetBranchPipelineExecute(r ApiGetBranchPipelineRequest) (*DevopsBranchPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsBranchPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchPipelineRunRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
}

func (r ApiGetBranchPipelineRunRequest) Execute() (*DevopsPipelineRun, *http.Response, error) {
	return r.ApiService.GetBranchPipelineRunExecute(r)
}

/*
GetBranchPipelineRun (MultiBranchesPipeline) Get details in the specified pipeline activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run id, the unique id for a pipeline once build.
 @return ApiGetBranchPipelineRunRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchPipelineRun(ctx context.Context, devops string, pipeline string, branch string, run string) ApiGetBranchPipelineRunRequest {
	return ApiGetBranchPipelineRunRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return DevopsPipelineRun
func (a *DevOpsPipelineAPIService) GetBranchPipelineRunExecute(r ApiGetBranchPipelineRunRequest) (*DevopsPipelineRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsPipelineRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchPipelineRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchPipelineRunNodesRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	limit *string
}

// the limit item count of the search.
func (r ApiGetBranchPipelineRunNodesRequest) Limit(limit string) ApiGetBranchPipelineRunNodesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBranchPipelineRunNodesRequest) Execute() ([]DevopsBranchPipelineRunNodes, *http.Response, error) {
	return r.ApiService.GetBranchPipelineRunNodesExecute(r)
}

/*
GetBranchPipelineRunNodes (MultiBranchesPipeline) Get run nodes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run id, the unique id for a pipeline once build.
 @return ApiGetBranchPipelineRunNodesRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchPipelineRunNodes(ctx context.Context, devops string, pipeline string, branch string, run string) ApiGetBranchPipelineRunNodesRequest {
	return ApiGetBranchPipelineRunNodesRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return []DevopsBranchPipelineRunNodes
func (a *DevOpsPipelineAPIService) GetBranchPipelineRunNodesExecute(r ApiGetBranchPipelineRunNodesRequest) ([]DevopsBranchPipelineRunNodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsBranchPipelineRunNodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchPipelineRunNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = "limit=10000"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBranchRunLogRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	start *string
}

// the item number that the search starts from.
func (r ApiGetBranchRunLogRequest) Start(start string) ApiGetBranchRunLogRequest {
	r.start = &start
	return r
}

func (r ApiGetBranchRunLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBranchRunLogExecute(r)
}

/*
GetBranchRunLog (MultiBranchesPipeline) Get run logs of the specified pipeline activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetBranchRunLogRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchRunLog(ctx context.Context, devops string, pipeline string, branch string, run string) ApiGetBranchRunLogRequest {
	return ApiGetBranchRunLogRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) GetBranchRunLogExecute(r ApiGetBranchRunLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchRunLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue string = "start=0"
		r.start = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBranchStepLogRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	node string
	step string
	start *string
}

// the item number that the search starts from.
func (r ApiGetBranchStepLogRequest) Start(start string) ApiGetBranchStepLogRequest {
	r.start = &start
	return r
}

func (r ApiGetBranchStepLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBranchStepLogExecute(r)
}

/*
GetBranchStepLog (MultiBranchesPipeline) Get the step logs in the specified pipeline activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run id, the unique id for a pipeline once build.
 @param node pipeline node id, the stage in pipeline.
 @param step pipeline step id, the step in pipeline.
 @return ApiGetBranchStepLogRequest
*/
func (a *DevOpsPipelineAPIService) GetBranchStepLog(ctx context.Context, devops string, pipeline string, branch string, run string, node string, step string) ApiGetBranchStepLogRequest {
	return ApiGetBranchStepLogRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
		node: node,
		step: step,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) GetBranchStepLogExecute(r ApiGetBranchStepLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetBranchStepLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/nodes/{node}/steps/{step}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step"+"}", url.PathEscape(parameterValueToString(r.step, "step")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue string = "start=0"
		r.start = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConsoleLogRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
}

func (r ApiGetConsoleLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetConsoleLogExecute(r)
}

/*
GetConsoleLog Get scan reponsitory logs in the specified pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @return ApiGetConsoleLogRequest
*/
func (a *DevOpsPipelineAPIService) GetConsoleLog(ctx context.Context, devops string, pipeline string) ApiGetConsoleLogRequest {
	return ApiGetConsoleLogRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) GetConsoleLogExecute(r ApiGetConsoleLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetConsoleLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/consolelog"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCrumbRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
}

func (r ApiGetCrumbRequest) Execute() (*DevopsCrumb, *http.Response, error) {
	return r.ApiService.GetCrumbExecute(r)
}

/*
GetCrumb Get crumb issuer. A CrumbIssuer represents an algorithm to generate a nonce value, known as a crumb, to counter cross site request forgery exploits. Crumbs are typically hashes incorporating information that uniquely identifies an agent that sends a request, along with a guarded secret so that the crumb value cannot be forged by a third party.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCrumbRequest
*/
func (a *DevOpsPipelineAPIService) GetCrumb(ctx context.Context) ApiGetCrumbRequest {
	return ApiGetCrumbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DevopsCrumb
func (a *DevOpsPipelineAPIService) GetCrumbExecute(r ApiGetCrumbRequest) (*DevopsCrumb, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsCrumb
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetCrumb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/crumbissuer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeStepsRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
	node string
}

func (r ApiGetNodeStepsRequest) Execute() ([]DevopsNodeSteps, *http.Response, error) {
	return r.ApiService.GetNodeStepsExecute(r)
}

/*
GetNodeSteps Get all steps in the specified node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops the name of devops project
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build
 @param node pipeline node ID, the stage in pipeline.
 @return ApiGetNodeStepsRequest
*/
func (a *DevOpsPipelineAPIService) GetNodeSteps(ctx context.Context, devops string, pipeline string, run string, node string) ApiGetNodeStepsRequest {
	return ApiGetNodeStepsRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
		node: node,
	}
}

// Execute executes the request
//  @return []DevopsNodeSteps
func (a *DevOpsPipelineAPIService) GetNodeStepsExecute(r ApiGetNodeStepsRequest) ([]DevopsNodeSteps, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsNodeSteps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetNodeSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodesDetailRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
}

func (r ApiGetNodesDetailRequest) Execute() ([]DevopsNodesDetail, *http.Response, error) {
	return r.ApiService.GetNodesDetailExecute(r)
}

/*
GetNodesDetail Get steps details inside a activity node. For a node, the steps which defined inside the node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetNodesDetailRequest
*/
func (a *DevOpsPipelineAPIService) GetNodesDetail(ctx context.Context, devops string, pipeline string, run string) ApiGetNodesDetailRequest {
	return ApiGetNodesDetailRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return []DevopsNodesDetail
func (a *DevOpsPipelineAPIService) GetNodesDetailExecute(r ApiGetNodesDetailRequest) ([]DevopsNodesDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsNodesDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetNodesDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/nodesdetail"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
}

func (r ApiGetPipelineRequest) Execute() (*DevopsPipeline, *http.Response, error) {
	return r.ApiService.GetPipelineExecute(r)
}

/*
GetPipeline Get the specified pipeline of the DevOps project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @return ApiGetPipelineRequest
*/
func (a *DevOpsPipelineAPIService) GetPipeline(ctx context.Context, devops string, pipeline string) ApiGetPipelineRequest {
	return ApiGetPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return DevopsPipeline
func (a *DevOpsPipelineAPIService) GetPipelineExecute(r ApiGetPipelineRequest) (*DevopsPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineBranchRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	filter *string
	start *string
	limit *string
}

// filter remote scm. e.g. origin
func (r ApiGetPipelineBranchRequest) Filter(filter string) ApiGetPipelineBranchRequest {
	r.filter = &filter
	return r
}

// the count of branches start.
func (r ApiGetPipelineBranchRequest) Start(start string) ApiGetPipelineBranchRequest {
	r.start = &start
	return r
}

// the count of branches limit.
func (r ApiGetPipelineBranchRequest) Limit(limit string) ApiGetPipelineBranchRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPipelineBranchRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPipelineBranchExecute(r)
}

/*
GetPipelineBranch (MultiBranchesPipeline) Get all branches in the specified pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @return ApiGetPipelineBranchRequest
*/
func (a *DevOpsPipelineAPIService) GetPipelineBranch(ctx context.Context, devops string, pipeline string) ApiGetPipelineBranchRequest {
	return ApiGetPipelineBranchRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *DevOpsPipelineAPIService) GetPipelineBranchExecute(r ApiGetPipelineBranchRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetPipelineBranch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue string = "start=0"
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = "limit=100"
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
}

func (r ApiGetPipelineRunRequest) Execute() (*DevopsPipelineRun, *http.Response, error) {
	return r.ApiService.GetPipelineRunExecute(r)
}

/*
GetPipelineRun Get details in the specified pipeline activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops the name of devops project
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetPipelineRunRequest
*/
func (a *DevOpsPipelineAPIService) GetPipelineRun(ctx context.Context, devops string, pipeline string, run string) ApiGetPipelineRunRequest {
	return ApiGetPipelineRunRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return DevopsPipelineRun
func (a *DevOpsPipelineAPIService) GetPipelineRunExecute(r ApiGetPipelineRunRequest) (*DevopsPipelineRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsPipelineRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetPipelineRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunNodesRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
}

func (r ApiGetPipelineRunNodesRequest) Execute() ([]DevopsPipelineRunNodes, *http.Response, error) {
	return r.ApiService.GetPipelineRunNodesExecute(r)
}

/*
GetPipelineRunNodes Get all nodes in the specified activity. node is the stage in the pipeline task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops the name of devops project
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build
 @return ApiGetPipelineRunNodesRequest
*/
func (a *DevOpsPipelineAPIService) GetPipelineRunNodes(ctx context.Context, devops string, pipeline string, run string) ApiGetPipelineRunNodesRequest {
	return ApiGetPipelineRunNodesRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return []DevopsPipelineRunNodes
func (a *DevOpsPipelineAPIService) GetPipelineRunNodesExecute(r ApiGetPipelineRunNodesRequest) ([]DevopsPipelineRunNodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DevopsPipelineRunNodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetPipelineRunNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRunLogRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
	start *string
}

// the item number that the search starts from.
func (r ApiGetRunLogRequest) Start(start string) ApiGetRunLogRequest {
	r.start = &start
	return r
}

func (r ApiGetRunLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRunLogExecute(r)
}

/*
GetRunLog Get run logs of the specified pipeline activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiGetRunLogRequest
*/
func (a *DevOpsPipelineAPIService) GetRunLog(ctx context.Context, devops string, pipeline string, run string) ApiGetRunLogRequest {
	return ApiGetRunLogRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) GetRunLogExecute(r ApiGetRunLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetRunLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue string = "start=0"
		r.start = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetStepLogRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
	node string
	step string
	start *string
}

// the item number that the search starts from.
func (r ApiGetStepLogRequest) Start(start string) ApiGetStepLogRequest {
	r.start = &start
	return r
}

func (r ApiGetStepLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetStepLogExecute(r)
}

/*
GetStepLog Get pipelines step log.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @param node pipeline node ID, the stage in pipeline.
 @param step pipeline step ID, the step in pipeline.
 @return ApiGetStepLogRequest
*/
func (a *DevOpsPipelineAPIService) GetStepLog(ctx context.Context, devops string, pipeline string, run string, node string, step string) ApiGetStepLogRequest {
	return ApiGetStepLogRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
		node: node,
		step: step,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) GetStepLogExecute(r ApiGetStepLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.GetStepLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step"+"}", url.PathEscape(parameterValueToString(r.step, "step")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue string = "start=0"
		r.start = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListPipelineRunsRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	pipeline string
	devops string
	start *string
	limit *string
	branch *string
}

// the item number that the search starts from
func (r ApiListPipelineRunsRequest) Start(start string) ApiListPipelineRunsRequest {
	r.start = &start
	return r
}

// the limit item count of the search
func (r ApiListPipelineRunsRequest) Limit(limit string) ApiListPipelineRunsRequest {
	r.limit = &limit
	return r
}

// the name of branch, same as repository branch, will be filtered by branch.
func (r ApiListPipelineRunsRequest) Branch(branch string) ApiListPipelineRunsRequest {
	r.branch = &branch
	return r
}

func (r ApiListPipelineRunsRequest) Execute() (*DevopsPipelineRunList, *http.Response, error) {
	return r.ApiService.ListPipelineRunsExecute(r)
}

/*
ListPipelineRuns Get all runs of the specified pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pipeline the name of the CI/CD pipeline
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @return ApiListPipelineRunsRequest
*/
func (a *DevOpsPipelineAPIService) ListPipelineRuns(ctx context.Context, pipeline string, devops string) ApiListPipelineRunsRequest {
	return ApiListPipelineRunsRequest{
		ApiService: a,
		ctx: ctx,
		pipeline: pipeline,
		devops: devops,
	}
}

// Execute executes the request
//  @return DevopsPipelineRunList
func (a *DevOpsPipelineAPIService) ListPipelineRunsExecute(r ApiListPipelineRunsRequest) (*DevopsPipelineRunList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsPipelineRunList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.ListPipelineRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.branch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "branch", r.branch, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPipelinesRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	q *string
	filter *string
	start *string
	limit *string
}

// query pipelines, condition for filtering.
func (r ApiListPipelinesRequest) Q(q string) ApiListPipelinesRequest {
	r.q = &q
	return r
}

// Filter some types of jobs. e.g. no-folder，will not get a job of type folder
func (r ApiListPipelinesRequest) Filter(filter string) ApiListPipelinesRequest {
	r.filter = &filter
	return r
}

// the item number that the search starts from.
func (r ApiListPipelinesRequest) Start(start string) ApiListPipelinesRequest {
	r.start = &start
	return r
}

// the limit item count of the search.
func (r ApiListPipelinesRequest) Limit(limit string) ApiListPipelinesRequest {
	r.limit = &limit
	return r
}

func (r ApiListPipelinesRequest) Execute() (*DevopsPipelineList, *http.Response, error) {
	return r.ApiService.ListPipelinesExecute(r)
}

/*
ListPipelines Search DevOps resource. More info: https://github.com/jenkinsci/blueocean-plugin/tree/master/blueocean-rest#get-pipelines-across-organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPipelinesRequest
*/
func (a *DevOpsPipelineAPIService) ListPipelines(ctx context.Context) ApiListPipelinesRequest {
	return ApiListPipelinesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DevopsPipelineList
func (a *DevOpsPipelineAPIService) ListPipelinesExecute(r ApiListPipelinesRequest) (*DevopsPipelineList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsPipelineList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.ListPipelines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayBranchPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
}

func (r ApiReplayBranchPipelineRequest) Execute() (*DevopsReplayPipeline, *http.Response, error) {
	return r.ApiService.ReplayBranchPipelineExecute(r)
}

/*
ReplayBranchPipeline (MultiBranchesPipeline) Replay the specified pipeline of the DevOps project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiReplayBranchPipelineRequest
*/
func (a *DevOpsPipelineAPIService) ReplayBranchPipeline(ctx context.Context, devops string, pipeline string, branch string, run string) ApiReplayBranchPipelineRequest {
	return ApiReplayBranchPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return DevopsReplayPipeline
func (a *DevOpsPipelineAPIService) ReplayBranchPipelineExecute(r ApiReplayBranchPipelineRequest) (*DevopsReplayPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsReplayPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.ReplayBranchPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/replay"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplayPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
}

func (r ApiReplayPipelineRequest) Execute() (*DevopsReplayPipeline, *http.Response, error) {
	return r.ApiService.ReplayPipelineExecute(r)
}

/*
ReplayPipeline Replay pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiReplayPipelineRequest
*/
func (a *DevOpsPipelineAPIService) ReplayPipeline(ctx context.Context, devops string, pipeline string, run string) ApiReplayPipelineRequest {
	return ApiReplayPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return DevopsReplayPipeline
func (a *DevOpsPipelineAPIService) ReplayPipelineExecute(r ApiReplayPipelineRequest) (*DevopsReplayPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsReplayPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.ReplayPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/replay"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunBranchPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	body *DevopsRunPayload
}

func (r ApiRunBranchPipelineRequest) Body(body DevopsRunPayload) ApiRunBranchPipelineRequest {
	r.body = &body
	return r
}

func (r ApiRunBranchPipelineRequest) Execute() (*DevopsRunPipeline, *http.Response, error) {
	return r.ApiService.RunBranchPipelineExecute(r)
}

/*
RunBranchPipeline (MultiBranchesPipeline) Run the specified pipeline of the DevOps project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @return ApiRunBranchPipelineRequest
*/
func (a *DevOpsPipelineAPIService) RunBranchPipeline(ctx context.Context, devops string, pipeline string, branch string) ApiRunBranchPipelineRequest {
	return ApiRunBranchPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
	}
}

// Execute executes the request
//  @return DevopsRunPipeline
func (a *DevOpsPipelineAPIService) RunBranchPipelineExecute(r ApiRunBranchPipelineRequest) (*DevopsRunPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsRunPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.RunBranchPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	body *DevopsRunPayload
}

func (r ApiRunPipelineRequest) Body(body DevopsRunPayload) ApiRunPipelineRequest {
	r.body = &body
	return r
}

func (r ApiRunPipelineRequest) Execute() (*DevopsRunPipeline, *http.Response, error) {
	return r.ApiService.RunPipelineExecute(r)
}

/*
RunPipeline Run pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @return ApiRunPipelineRequest
*/
func (a *DevOpsPipelineAPIService) RunPipeline(ctx context.Context, devops string, pipeline string) ApiRunPipelineRequest {
	return ApiRunPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return DevopsRunPipeline
func (a *DevOpsPipelineAPIService) RunPipelineExecute(r ApiRunPipelineRequest) (*DevopsRunPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsRunPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.RunPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScanBranchRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	delay *string
}

// the delay time to scan
func (r ApiScanBranchRequest) Delay(delay string) ApiScanBranchRequest {
	r.delay = &delay
	return r
}

func (r ApiScanBranchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScanBranchExecute(r)
}

/*
ScanBranch Scan remote Repository, Start a build if have new branch.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @return ApiScanBranchRequest
*/
func (a *DevOpsPipelineAPIService) ScanBranch(ctx context.Context, devops string, pipeline string) ApiScanBranchRequest {
	return ApiScanBranchRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) ScanBranchExecute(r ApiScanBranchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.ScanBranch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/scan"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.delay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delay", r.delay, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStopBranchPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	blocking *string
	timeOutInSecs *string
}

// stop and between each retries will sleep.
func (r ApiStopBranchPipelineRequest) Blocking(blocking string) ApiStopBranchPipelineRequest {
	r.blocking = &blocking
	return r
}

// the time of stop and between each retries sleep.
func (r ApiStopBranchPipelineRequest) TimeOutInSecs(timeOutInSecs string) ApiStopBranchPipelineRequest {
	r.timeOutInSecs = &timeOutInSecs
	return r
}

func (r ApiStopBranchPipelineRequest) Execute() (*DevopsStopPipeline, *http.Response, error) {
	return r.ApiService.StopBranchPipelineExecute(r)
}

/*
StopBranchPipeline (MultiBranchesPipeline) Stop the specified pipeline of the DevOps project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiStopBranchPipelineRequest
*/
func (a *DevOpsPipelineAPIService) StopBranchPipeline(ctx context.Context, devops string, pipeline string, branch string, run string) ApiStopBranchPipelineRequest {
	return ApiStopBranchPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return DevopsStopPipeline
func (a *DevOpsPipelineAPIService) StopBranchPipelineExecute(r ApiStopBranchPipelineRequest) (*DevopsStopPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsStopPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.StopBranchPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blocking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blocking", r.blocking, "form", "")
	} else {
		var defaultValue string = "blocking=false"
		r.blocking = &defaultValue
	}
	if r.timeOutInSecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeOutInSecs", r.timeOutInSecs, "form", "")
	} else {
		var defaultValue string = "timeOutInSecs=10"
		r.timeOutInSecs = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopPipelineRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
	blocking *string
	timeOutInSecs *string
}

// stop and between each retries will sleep.
func (r ApiStopPipelineRequest) Blocking(blocking string) ApiStopPipelineRequest {
	r.blocking = &blocking
	return r
}

// the time of stop and between each retries sleep.
func (r ApiStopPipelineRequest) TimeOutInSecs(timeOutInSecs string) ApiStopPipelineRequest {
	r.timeOutInSecs = &timeOutInSecs
	return r
}

func (r ApiStopPipelineRequest) Execute() (*DevopsStopPipeline, *http.Response, error) {
	return r.ApiService.StopPipelineExecute(r)
}

/*
StopPipeline Stop pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @return ApiStopPipelineRequest
*/
func (a *DevOpsPipelineAPIService) StopPipeline(ctx context.Context, devops string, pipeline string, run string) ApiStopPipelineRequest {
	return ApiStopPipelineRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return DevopsStopPipeline
func (a *DevOpsPipelineAPIService) StopPipelineExecute(r ApiStopPipelineRequest) (*DevopsStopPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DevopsStopPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.StopPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blocking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blocking", r.blocking, "form", "")
	} else {
		var defaultValue string = "blocking=false"
		r.blocking = &defaultValue
	}
	if r.timeOutInSecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeOutInSecs", r.timeOutInSecs, "form", "")
	} else {
		var defaultValue string = "timeOutInSecs=10"
		r.timeOutInSecs = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitBranchInputStepRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	branch string
	run string
	node string
	step string
	body *DevopsCheckPlayload
}

func (r ApiSubmitBranchInputStepRequest) Body(body DevopsCheckPlayload) ApiSubmitBranchInputStepRequest {
	r.body = &body
	return r
}

func (r ApiSubmitBranchInputStepRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubmitBranchInputStepExecute(r)
}

/*
SubmitBranchInputStep (MultiBranchesPipeline) Proceed or Break the paused pipeline which waiting for user input.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param branch the name of branch, same as repository branch.
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @param node pipeline node ID, the stage in pipeline.
 @param step pipeline step ID, the step in pipeline.
 @return ApiSubmitBranchInputStepRequest
*/
func (a *DevOpsPipelineAPIService) SubmitBranchInputStep(ctx context.Context, devops string, pipeline string, branch string, run string, node string, step string) ApiSubmitBranchInputStepRequest {
	return ApiSubmitBranchInputStepRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		branch: branch,
		run: run,
		node: node,
		step: step,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) SubmitBranchInputStepExecute(r ApiSubmitBranchInputStepRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.SubmitBranchInputStep")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/branches/{branch}/runs/{run}/nodes/{node}/steps/{step}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step"+"}", url.PathEscape(parameterValueToString(r.step, "step")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitInputStepRequest struct {
	ctx context.Context
	ApiService *DevOpsPipelineAPIService
	devops string
	pipeline string
	run string
	node string
	step string
	body *DevopsCheckPlayload
}

func (r ApiSubmitInputStepRequest) Body(body DevopsCheckPlayload) ApiSubmitInputStepRequest {
	r.body = &body
	return r
}

func (r ApiSubmitInputStepRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubmitInputStepExecute(r)
}

/*
SubmitInputStep Proceed or Break the paused pipeline which is waiting for user input.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devops DevOps project's ID, e.g. project-RRRRAzLBlLEm
 @param pipeline the name of the CI/CD pipeline
 @param run pipeline run ID, the unique ID for a pipeline once build.
 @param node pipeline node ID, the stage in pipeline.
 @param step pipeline step ID
 @return ApiSubmitInputStepRequest
*/
func (a *DevOpsPipelineAPIService) SubmitInputStep(ctx context.Context, devops string, pipeline string, run string, node string, step string) ApiSubmitInputStepRequest {
	return ApiSubmitInputStepRequest{
		ApiService: a,
		ctx: ctx,
		devops: devops,
		pipeline: pipeline,
		run: run,
		node: node,
		step: step,
	}
}

// Execute executes the request
func (a *DevOpsPipelineAPIService) SubmitInputStepExecute(r ApiSubmitInputStepRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevOpsPipelineAPIService.SubmitInputStep")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/devops.kubesphere.io/v1alpha2/devops/{devops}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}"
	localVarPath = strings.Replace(localVarPath, "{"+"devops"+"}", url.PathEscape(parameterValueToString(r.devops, "devops")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step"+"}", url.PathEscape(parameterValueToString(r.step, "step")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
