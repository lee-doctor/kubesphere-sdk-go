/*
KubeSphere

KubeSphere OpenAPI

API version: v3.1.0
Contact: info@kubesphere.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// LogQueryAPIService LogQueryAPI service
type LogQueryAPIService service

type ApiQueryLogsRequest struct {
	ctx context.Context
	ApiService *LogQueryAPIService
	operation *string
	namespaces *string
	namespaceQuery *string
	workloads *string
	workloadQuery *string
	pods *string
	podQuery *string
	containers *string
	containerQuery *string
	logQuery *string
	interval *string
	startTime *string
	endTime *string
	sort *string
	from *int32
	size *int32
}

// Operation type. This can be one of four types: query (for querying logs), statistics (for retrieving statistical data), histogram (for displaying log count by time interval) and export (for exporting logs). Defaults to query.
func (r ApiQueryLogsRequest) Operation(operation string) ApiQueryLogsRequest {
	r.operation = &operation
	return r
}

// A comma-separated list of namespaces. This field restricts the query to specified namespaces. For example, the following filter matches the namespace my-ns and demo-ns: &#x60;my-ns,demo-ns&#x60;
func (r ApiQueryLogsRequest) Namespaces(namespaces string) ApiQueryLogsRequest {
	r.namespaces = &namespaces
	return r
}

// A comma-separated list of keywords. Differing from **namespaces**, this field performs fuzzy matching on namespaces. For example, the following value limits the query to namespaces whose name contains the word my(My,MY,...) *OR* demo(Demo,DemO,...): &#x60;my,demo&#x60;.
func (r ApiQueryLogsRequest) NamespaceQuery(namespaceQuery string) ApiQueryLogsRequest {
	r.namespaceQuery = &namespaceQuery
	return r
}

// A comma-separated list of workloads. This field restricts the query to specified workloads. For example, the following filter matches the workload my-wl and demo-wl: &#x60;my-wl,demo-wl&#x60;
func (r ApiQueryLogsRequest) Workloads(workloads string) ApiQueryLogsRequest {
	r.workloads = &workloads
	return r
}

// A comma-separated list of keywords. Differing from **workloads**, this field performs fuzzy matching on workloads. For example, the following value limits the query to workloads whose name contains the word my(My,MY,...) *OR* demo(Demo,DemO,...): &#x60;my,demo&#x60;.
func (r ApiQueryLogsRequest) WorkloadQuery(workloadQuery string) ApiQueryLogsRequest {
	r.workloadQuery = &workloadQuery
	return r
}

// A comma-separated list of pods. This field restricts the query to specified pods. For example, the following filter matches the pod my-po and demo-po: &#x60;my-po,demo-po&#x60;
func (r ApiQueryLogsRequest) Pods(pods string) ApiQueryLogsRequest {
	r.pods = &pods
	return r
}

// A comma-separated list of keywords. Differing from **pods**, this field performs fuzzy matching on pods. For example, the following value limits the query to pods whose name contains the word my(My,MY,...) *OR* demo(Demo,DemO,...): &#x60;my,demo&#x60;.
func (r ApiQueryLogsRequest) PodQuery(podQuery string) ApiQueryLogsRequest {
	r.podQuery = &podQuery
	return r
}

// A comma-separated list of containers. This field restricts the query to specified containers. For example, the following filter matches the container my-cont and demo-cont: &#x60;my-cont,demo-cont&#x60;
func (r ApiQueryLogsRequest) Containers(containers string) ApiQueryLogsRequest {
	r.containers = &containers
	return r
}

// A comma-separated list of keywords. Differing from **containers**, this field performs fuzzy matching on containers. For example, the following value limits the query to containers whose name contains the word my(My,MY,...) *OR* demo(Demo,DemO,...): &#x60;my,demo&#x60;.
func (r ApiQueryLogsRequest) ContainerQuery(containerQuery string) ApiQueryLogsRequest {
	r.containerQuery = &containerQuery
	return r
}

// A comma-separated list of keywords. The query returns logs which contain at least one keyword. Case-insensitive matching. For example, if the field is set to &#x60;err,INFO&#x60;, the query returns any log containing err(ERR,Err,...) *OR* INFO(info,InFo,...).
func (r ApiQueryLogsRequest) LogQuery(logQuery string) ApiQueryLogsRequest {
	r.logQuery = &logQuery
	return r
}

// Time interval. It requires **operation** is set to histogram. The format is [0-9]+[smhdwMqy]. Defaults to 15m (i.e. 15 min).
func (r ApiQueryLogsRequest) Interval(interval string) ApiQueryLogsRequest {
	r.interval = &interval
	return r
}

// Start time of query. Default to 0. The format is a string representing seconds since the epoch, eg. 1559664000.
func (r ApiQueryLogsRequest) StartTime(startTime string) ApiQueryLogsRequest {
	r.startTime = &startTime
	return r
}

// End time of query. Default to now. The format is a string representing seconds since the epoch, eg. 1559664000.
func (r ApiQueryLogsRequest) EndTime(endTime string) ApiQueryLogsRequest {
	r.endTime = &endTime
	return r
}

// Sort order. One of asc, desc. This field sorts logs by timestamp.
func (r ApiQueryLogsRequest) Sort(sort string) ApiQueryLogsRequest {
	r.sort = &sort
	return r
}

// The offset from the result set. This field returns query results from the specified offset. It requires **operation** is set to query. Defaults to 0 (i.e. from the beginning of the result set).
func (r ApiQueryLogsRequest) From(from int32) ApiQueryLogsRequest {
	r.from = &from
	return r
}

// Size of result to return. It requires **operation** is set to query. Defaults to 10 (i.e. 10 log records).
func (r ApiQueryLogsRequest) Size(size int32) ApiQueryLogsRequest {
	r.size = &size
	return r
}

func (r ApiQueryLogsRequest) Execute() (*V1alpha2APIResponse, *http.Response, error) {
	return r.ApiService.QueryLogsExecute(r)
}

/*
QueryLogs Query logs against the cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryLogsRequest
*/
func (a *LogQueryAPIService) QueryLogs(ctx context.Context) ApiQueryLogsRequest {
	return ApiQueryLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1alpha2APIResponse
func (a *LogQueryAPIService) QueryLogsExecute(r ApiQueryLogsRequest) (*V1alpha2APIResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1alpha2APIResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogQueryAPIService.QueryLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/tenant.kubesphere.io/v1alpha2/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.operation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operation", r.operation, "form", "")
	} else {
		var defaultValue string = "query"
		r.operation = &defaultValue
	}
	if r.namespaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespaces", r.namespaces, "form", "")
	}
	if r.namespaceQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace_query", r.namespaceQuery, "form", "")
	}
	if r.workloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workloads", r.workloads, "form", "")
	}
	if r.workloadQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workload_query", r.workloadQuery, "form", "")
	}
	if r.pods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pods", r.pods, "form", "")
	}
	if r.podQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pod_query", r.podQuery, "form", "")
	}
	if r.containers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containers", r.containers, "form", "")
	}
	if r.containerQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "container_query", r.containerQuery, "form", "")
	}
	if r.logQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "log_query", r.logQuery, "form", "")
	}
	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	} else {
		var defaultValue string = "15m"
		r.interval = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sort = &defaultValue
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	} else {
		var defaultValue int32 = 0
		r.from = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
