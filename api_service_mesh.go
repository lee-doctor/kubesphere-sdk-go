/*
KubeSphere

KubeSphere OpenAPI

API version: v3.1.0
Contact: info@kubesphere.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ServiceMeshAPIService ServiceMeshAPI service
type ServiceMeshAPIService service

type ApiGetAppHealthRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	app string
	rateInterval *string
	queryTime *string
}

// the rate interval used for fetching error rate
func (r ApiGetAppHealthRequest) RateInterval(rateInterval string) ApiGetAppHealthRequest {
	r.rateInterval = &rateInterval
	return r
}

// the time to use for query
func (r ApiGetAppHealthRequest) QueryTime(queryTime string) ApiGetAppHealthRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetAppHealthRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAppHealthExecute(r)
}

/*
GetAppHealth Get app health

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of a namespace
 @param app app name
 @return ApiGetAppHealthRequest
*/
func (a *ServiceMeshAPIService) GetAppHealth(ctx context.Context, namespace string, app string) ApiGetAppHealthRequest {
	return ApiGetAppHealthRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		app: app,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetAppHealthExecute(r ApiGetAppHealthRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetAppHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/apps/{app}/health"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterValueToString(r.app, "app")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rateInterval == nil {
		return localVarReturnValue, nil, reportError("rateInterval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppMetricsRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	app string
	filters *string
	queryTime *string
	duration *string
	step *string
	rateInterval *string
	direction *string
	quantiles *string
	byLabels *string
	requestProtocol *string
	reporter *string
}

// type of metrics type, fetch all metrics when empty, e.g. request_count, request_duration, request_error_count
func (r ApiGetAppMetricsRequest) Filters(filters string) ApiGetAppMetricsRequest {
	r.filters = &filters
	return r
}

// from which UNIX time to extract metrics
func (r ApiGetAppMetricsRequest) QueryTime(queryTime string) ApiGetAppMetricsRequest {
	r.queryTime = &queryTime
	return r
}

// duration of the query period, in seconds
func (r ApiGetAppMetricsRequest) Duration(duration string) ApiGetAppMetricsRequest {
	r.duration = &duration
	return r
}

// step between graph data points, in seconds.
func (r ApiGetAppMetricsRequest) Step(step string) ApiGetAppMetricsRequest {
	r.step = &step
	return r
}

// metrics rate intervals, e.g. 20s
func (r ApiGetAppMetricsRequest) RateInterval(rateInterval string) ApiGetAppMetricsRequest {
	r.rateInterval = &rateInterval
	return r
}

// traffic direction: &#39;inbound&#39; or &#39;outbound&#39;
func (r ApiGetAppMetricsRequest) Direction(direction string) ApiGetAppMetricsRequest {
	r.direction = &direction
	return r
}

// list of quantiles to fetch, fetch no quantiles when empty. eg. 0.5, 0.9, 0.99
func (r ApiGetAppMetricsRequest) Quantiles(quantiles string) ApiGetAppMetricsRequest {
	r.quantiles = &quantiles
	return r
}

// list of labels to use for grouping metrics(via Prometheus &#39;by&#39; clause), e.g. source_workload, destination_service_name
func (r ApiGetAppMetricsRequest) ByLabels(byLabels string) ApiGetAppMetricsRequest {
	r.byLabels = &byLabels
	return r
}

// request protocol for the telemetry, e.g. http/tcp/grpc
func (r ApiGetAppMetricsRequest) RequestProtocol(requestProtocol string) ApiGetAppMetricsRequest {
	r.requestProtocol = &requestProtocol
	return r
}

// istio telemetry reporter, &#39;source&#39; or &#39;destination&#39;
func (r ApiGetAppMetricsRequest) Reporter(reporter string) ApiGetAppMetricsRequest {
	r.reporter = &reporter
	return r
}

func (r ApiGetAppMetricsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAppMetricsExecute(r)
}

/*
GetAppMetrics Get app metrics from a specific namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of the namespace
 @param app name of the app
 @return ApiGetAppMetricsRequest
*/
func (a *ServiceMeshAPIService) GetAppMetrics(ctx context.Context, namespace string, app string) ApiGetAppMetricsRequest {
	return ApiGetAppMetricsRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		app: app,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetAppMetricsExecute(r ApiGetAppMetricsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetAppMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/apps/{app}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"app"+"}", url.PathEscape(parameterValueToString(r.app, "app")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[]", r.filters, "form", "")
	} else {
		var defaultValue string = "[]"
		r.filters = &defaultValue
	}
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	} else {
		var defaultValue string = "1800"
		r.duration = &defaultValue
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	} else {
		var defaultValue string = "15"
		r.step = &defaultValue
	}
	if r.rateInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	} else {
		var defaultValue string = "1m"
		r.rateInterval = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "outbound"
		r.direction = &defaultValue
	}
	if r.quantiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantiles[]", r.quantiles, "form", "")
	} else {
		var defaultValue string = "[]"
		r.quantiles = &defaultValue
	}
	if r.byLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "byLabels[]", r.byLabels, "form", "")
	} else {
		var defaultValue string = "[]"
		r.byLabels = &defaultValue
	}
	if r.requestProtocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestProtocol", r.requestProtocol, "form", "")
	} else {
		var defaultValue string = "all protocols"
		r.requestProtocol = &defaultValue
	}
	if r.reporter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporter", r.reporter, "form", "")
	} else {
		var defaultValue string = "source"
		r.reporter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceGraphRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	duration *string
	graphType *string
	groupBy *string
	queryTime *string
	injectServiceNodes *string
}

// duration of the query period, in seconds
func (r ApiGetNamespaceGraphRequest) Duration(duration string) ApiGetNamespaceGraphRequest {
	r.duration = &duration
	return r
}

// type of the generated service graph. Available graph types: [app, service, versionedApp, workload].
func (r ApiGetNamespaceGraphRequest) GraphType(graphType string) ApiGetNamespaceGraphRequest {
	r.graphType = &graphType
	return r
}

// app box grouping characteristic. Available groupings: [app, none, version].
func (r ApiGetNamespaceGraphRequest) GroupBy(groupBy string) ApiGetNamespaceGraphRequest {
	r.groupBy = &groupBy
	return r
}

// from which time point in UNIX timestamp, default now
func (r ApiGetNamespaceGraphRequest) QueryTime(queryTime string) ApiGetNamespaceGraphRequest {
	r.queryTime = &queryTime
	return r
}

// flag for injecting the requested service node between source and destination nodes.
func (r ApiGetNamespaceGraphRequest) InjectServiceNodes(injectServiceNodes string) ApiGetNamespaceGraphRequest {
	r.injectServiceNodes = &injectServiceNodes
	return r
}

func (r ApiGetNamespaceGraphRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNamespaceGraphExecute(r)
}

/*
GetNamespaceGraph Get service graph for a specific namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of a namespace
 @return ApiGetNamespaceGraphRequest
*/
func (a *ServiceMeshAPIService) GetNamespaceGraph(ctx context.Context, namespace string) ApiGetNamespaceGraphRequest {
	return ApiGetNamespaceGraphRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetNamespaceGraphExecute(r ApiGetNamespaceGraphRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetNamespaceGraph")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/graph"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	} else {
		var defaultValue string = "10m"
		r.duration = &defaultValue
	}
	if r.graphType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "graphType", r.graphType, "form", "")
	} else {
		var defaultValue string = "workload"
		r.graphType = &defaultValue
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", r.groupBy, "form", "")
	} else {
		var defaultValue string = "none"
		r.groupBy = &defaultValue
	}
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	if r.injectServiceNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "injectServiceNodes", r.injectServiceNodes, "form", "")
	} else {
		var defaultValue string = "false"
		r.injectServiceNodes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V1alpha2BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V1alpha2NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceHealthRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	rateInterval *string
	queryTime *string
}

// the rate interval used for fetching error rate
func (r ApiGetNamespaceHealthRequest) RateInterval(rateInterval string) ApiGetNamespaceHealthRequest {
	r.rateInterval = &rateInterval
	return r
}

// the time to use for query
func (r ApiGetNamespaceHealthRequest) QueryTime(queryTime string) ApiGetNamespaceHealthRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetNamespaceHealthRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNamespaceHealthExecute(r)
}

/*
GetNamespaceHealth Get app/service/workload health of a namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of a namespace
 @return ApiGetNamespaceHealthRequest
*/
func (a *ServiceMeshAPIService) GetNamespaceHealth(ctx context.Context, namespace string) ApiGetNamespaceHealthRequest {
	return ApiGetNamespaceHealthRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetNamespaceHealthExecute(r ApiGetNamespaceHealthRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetNamespaceHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/health"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rateInterval == nil {
		return localVarReturnValue, nil, reportError("rateInterval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V1alpha2BadRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V1alpha2NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNamespaceMetricsRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	filters *string
	queryTime *string
	duration *string
	step *string
	rateInterval *string
	direction *string
	quantiles *string
	byLabels *string
	requestProtocol *string
	reporter *string
}

// type of metrics type, fetch all metrics when empty, e.g. request_count, request_duration, request_error_count
func (r ApiGetNamespaceMetricsRequest) Filters(filters string) ApiGetNamespaceMetricsRequest {
	r.filters = &filters
	return r
}

// from which UNIX time to extract metrics
func (r ApiGetNamespaceMetricsRequest) QueryTime(queryTime string) ApiGetNamespaceMetricsRequest {
	r.queryTime = &queryTime
	return r
}

// duration of the query period, in seconds
func (r ApiGetNamespaceMetricsRequest) Duration(duration string) ApiGetNamespaceMetricsRequest {
	r.duration = &duration
	return r
}

// step between graph data points, in seconds.
func (r ApiGetNamespaceMetricsRequest) Step(step string) ApiGetNamespaceMetricsRequest {
	r.step = &step
	return r
}

// metrics rate intervals, e.g. 20s
func (r ApiGetNamespaceMetricsRequest) RateInterval(rateInterval string) ApiGetNamespaceMetricsRequest {
	r.rateInterval = &rateInterval
	return r
}

// traffic direction: &#39;inbound&#39; or &#39;outbound&#39;
func (r ApiGetNamespaceMetricsRequest) Direction(direction string) ApiGetNamespaceMetricsRequest {
	r.direction = &direction
	return r
}

// list of quantiles to fetch, fetch no quantiles when empty. eg. 0.5, 0.9, 0.99
func (r ApiGetNamespaceMetricsRequest) Quantiles(quantiles string) ApiGetNamespaceMetricsRequest {
	r.quantiles = &quantiles
	return r
}

// list of labels to use for grouping metrics(via Prometheus &#39;by&#39; clause), e.g. source_workload, destination_service_name
func (r ApiGetNamespaceMetricsRequest) ByLabels(byLabels string) ApiGetNamespaceMetricsRequest {
	r.byLabels = &byLabels
	return r
}

// request protocol for the telemetry, e.g. http/tcp/grpc
func (r ApiGetNamespaceMetricsRequest) RequestProtocol(requestProtocol string) ApiGetNamespaceMetricsRequest {
	r.requestProtocol = &requestProtocol
	return r
}

// istio telemetry reporter, &#39;source&#39; or &#39;destination&#39;
func (r ApiGetNamespaceMetricsRequest) Reporter(reporter string) ApiGetNamespaceMetricsRequest {
	r.reporter = &reporter
	return r
}

func (r ApiGetNamespaceMetricsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNamespaceMetricsExecute(r)
}

/*
GetNamespaceMetrics Get metrics from a specific namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of the namespace
 @return ApiGetNamespaceMetricsRequest
*/
func (a *ServiceMeshAPIService) GetNamespaceMetrics(ctx context.Context, namespace string) ApiGetNamespaceMetricsRequest {
	return ApiGetNamespaceMetricsRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetNamespaceMetricsExecute(r ApiGetNamespaceMetricsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetNamespaceMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[]", r.filters, "form", "")
	} else {
		var defaultValue string = "[]"
		r.filters = &defaultValue
	}
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	} else {
		var defaultValue string = "1800"
		r.duration = &defaultValue
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	} else {
		var defaultValue string = "15"
		r.step = &defaultValue
	}
	if r.rateInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	} else {
		var defaultValue string = "1m"
		r.rateInterval = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "outbound"
		r.direction = &defaultValue
	}
	if r.quantiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantiles[]", r.quantiles, "form", "")
	} else {
		var defaultValue string = "[]"
		r.quantiles = &defaultValue
	}
	if r.byLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "byLabels[]", r.byLabels, "form", "")
	} else {
		var defaultValue string = "[]"
		r.byLabels = &defaultValue
	}
	if r.requestProtocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestProtocol", r.requestProtocol, "form", "")
	} else {
		var defaultValue string = "all protocols"
		r.requestProtocol = &defaultValue
	}
	if r.reporter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporter", r.reporter, "form", "")
	} else {
		var defaultValue string = "source"
		r.reporter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceHealthRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	service string
	rateInterval *string
	queryTime *string
}

// the rate interval used for fetching error rate
func (r ApiGetServiceHealthRequest) RateInterval(rateInterval string) ApiGetServiceHealthRequest {
	r.rateInterval = &rateInterval
	return r
}

// the time to use for query
func (r ApiGetServiceHealthRequest) QueryTime(queryTime string) ApiGetServiceHealthRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetServiceHealthRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetServiceHealthExecute(r)
}

/*
GetServiceHealth Get service health

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of a namespace
 @param service service name
 @return ApiGetServiceHealthRequest
*/
func (a *ServiceMeshAPIService) GetServiceHealth(ctx context.Context, namespace string, service string) ApiGetServiceHealthRequest {
	return ApiGetServiceHealthRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		service: service,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetServiceHealthExecute(r ApiGetServiceHealthRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetServiceHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/services/{service}/health"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterValueToString(r.service, "service")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rateInterval == nil {
		return localVarReturnValue, nil, reportError("rateInterval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceMetricsRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	service string
	filters *string
	queryTime *string
	duration *string
	step *string
	rateInterval *string
	direction *string
	quantiles *string
	byLabels *string
	requestProtocol *string
	reporter *string
}

// type of metrics type, fetch all metrics when empty, e.g. request_count, request_duration, request_error_count
func (r ApiGetServiceMetricsRequest) Filters(filters string) ApiGetServiceMetricsRequest {
	r.filters = &filters
	return r
}

// from which UNIX time to extract metrics
func (r ApiGetServiceMetricsRequest) QueryTime(queryTime string) ApiGetServiceMetricsRequest {
	r.queryTime = &queryTime
	return r
}

// duration of the query period, in seconds
func (r ApiGetServiceMetricsRequest) Duration(duration string) ApiGetServiceMetricsRequest {
	r.duration = &duration
	return r
}

// step between graph data points, in seconds.
func (r ApiGetServiceMetricsRequest) Step(step string) ApiGetServiceMetricsRequest {
	r.step = &step
	return r
}

// metrics rate intervals, e.g. 20s
func (r ApiGetServiceMetricsRequest) RateInterval(rateInterval string) ApiGetServiceMetricsRequest {
	r.rateInterval = &rateInterval
	return r
}

// traffic direction: &#39;inbound&#39; or &#39;outbound&#39;
func (r ApiGetServiceMetricsRequest) Direction(direction string) ApiGetServiceMetricsRequest {
	r.direction = &direction
	return r
}

// list of quantiles to fetch, fetch no quantiles when empty. eg. 0.5, 0.9, 0.99
func (r ApiGetServiceMetricsRequest) Quantiles(quantiles string) ApiGetServiceMetricsRequest {
	r.quantiles = &quantiles
	return r
}

// list of labels to use for grouping metrics(via Prometheus &#39;by&#39; clause), e.g. source_workload, destination_service_name
func (r ApiGetServiceMetricsRequest) ByLabels(byLabels string) ApiGetServiceMetricsRequest {
	r.byLabels = &byLabels
	return r
}

// request protocol for the telemetry, e.g. http/tcp/grpc
func (r ApiGetServiceMetricsRequest) RequestProtocol(requestProtocol string) ApiGetServiceMetricsRequest {
	r.requestProtocol = &requestProtocol
	return r
}

// istio telemetry reporter, &#39;source&#39; or &#39;destination&#39;
func (r ApiGetServiceMetricsRequest) Reporter(reporter string) ApiGetServiceMetricsRequest {
	r.reporter = &reporter
	return r
}

func (r ApiGetServiceMetricsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetServiceMetricsExecute(r)
}

/*
GetServiceMetrics Get service metrics from a specific namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of the namespace
 @param service name of the service
 @return ApiGetServiceMetricsRequest
*/
func (a *ServiceMeshAPIService) GetServiceMetrics(ctx context.Context, namespace string, service string) ApiGetServiceMetricsRequest {
	return ApiGetServiceMetricsRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		service: service,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetServiceMetricsExecute(r ApiGetServiceMetricsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetServiceMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/services/{service}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterValueToString(r.service, "service")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[]", r.filters, "form", "")
	} else {
		var defaultValue string = "[]"
		r.filters = &defaultValue
	}
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	} else {
		var defaultValue string = "1800"
		r.duration = &defaultValue
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	} else {
		var defaultValue string = "15"
		r.step = &defaultValue
	}
	if r.rateInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	} else {
		var defaultValue string = "1m"
		r.rateInterval = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "outbound"
		r.direction = &defaultValue
	}
	if r.quantiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantiles[]", r.quantiles, "form", "")
	} else {
		var defaultValue string = "[]"
		r.quantiles = &defaultValue
	}
	if r.byLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "byLabels[]", r.byLabels, "form", "")
	} else {
		var defaultValue string = "[]"
		r.byLabels = &defaultValue
	}
	if r.requestProtocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestProtocol", r.requestProtocol, "form", "")
	} else {
		var defaultValue string = "all protocols"
		r.requestProtocol = &defaultValue
	}
	if r.reporter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporter", r.reporter, "form", "")
	} else {
		var defaultValue string = "source"
		r.reporter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceTracingRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	service string
	start *string
	end *string
	limit *string
	loopback *string
	maxDuration *string
	minDuration *string
}

// start of time range want to query, in unix timestamp
func (r ApiGetServiceTracingRequest) Start(start string) ApiGetServiceTracingRequest {
	r.start = &start
	return r
}

// end of time range want to query, in unix timestamp
func (r ApiGetServiceTracingRequest) End(end string) ApiGetServiceTracingRequest {
	r.end = &end
	return r
}

// maximum tracing entries returned at one query, default 10
func (r ApiGetServiceTracingRequest) Limit(limit string) ApiGetServiceTracingRequest {
	r.limit = &limit
	return r
}

// loopback of duration want to query, e.g. 30m/1h/2d
func (r ApiGetServiceTracingRequest) Loopback(loopback string) ApiGetServiceTracingRequest {
	r.loopback = &loopback
	return r
}

// maximum duration of a request
func (r ApiGetServiceTracingRequest) MaxDuration(maxDuration string) ApiGetServiceTracingRequest {
	r.maxDuration = &maxDuration
	return r
}

// minimum duration of a request
func (r ApiGetServiceTracingRequest) MinDuration(minDuration string) ApiGetServiceTracingRequest {
	r.minDuration = &minDuration
	return r
}

func (r ApiGetServiceTracingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetServiceTracingExecute(r)
}

/*
GetServiceTracing Get tracing of a service, should have servicemesh enabled first

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace namespace of service
 @param service name of service queried
 @return ApiGetServiceTracingRequest
*/
func (a *ServiceMeshAPIService) GetServiceTracing(ctx context.Context, namespace string, service string) ApiGetServiceTracingRequest {
	return ApiGetServiceTracingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		service: service,
	}
}

// Execute executes the request
func (a *ServiceMeshAPIService) GetServiceTracingExecute(r ApiGetServiceTracingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetServiceTracing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/services/{service}/traces"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", url.PathEscape(parameterValueToString(r.service, "service")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue string = "10"
		r.limit = &defaultValue
	}
	if r.loopback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loopback", r.loopback, "form", "")
	}
	if r.maxDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxDuration", r.maxDuration, "form", "")
	}
	if r.minDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minDuration", r.minDuration, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetWorkloadHealthRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	workload string
	rateInterval *string
	queryTime *string
}

// the rate interval used for fetching error rate
func (r ApiGetWorkloadHealthRequest) RateInterval(rateInterval string) ApiGetWorkloadHealthRequest {
	r.rateInterval = &rateInterval
	return r
}

// the time to use for query
func (r ApiGetWorkloadHealthRequest) QueryTime(queryTime string) ApiGetWorkloadHealthRequest {
	r.queryTime = &queryTime
	return r
}

func (r ApiGetWorkloadHealthRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetWorkloadHealthExecute(r)
}

/*
GetWorkloadHealth Get workload health

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of a namespace
 @param workload workload name
 @return ApiGetWorkloadHealthRequest
*/
func (a *ServiceMeshAPIService) GetWorkloadHealth(ctx context.Context, namespace string, workload string) ApiGetWorkloadHealthRequest {
	return ApiGetWorkloadHealthRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		workload: workload,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetWorkloadHealthExecute(r ApiGetWorkloadHealthRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetWorkloadHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/workloads/{workload}/health"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workload"+"}", url.PathEscape(parameterValueToString(r.workload, "workload")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rateInterval == nil {
		return localVarReturnValue, nil, reportError("rateInterval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkloadMetricsRequest struct {
	ctx context.Context
	ApiService *ServiceMeshAPIService
	namespace string
	workload string
	filters *string
	queryTime *string
	duration *string
	step *string
	rateInterval *string
	direction *string
	quantiles *string
	byLabels *string
	requestProtocol *string
	reporter *string
}

// type of metrics type, fetch all metrics when empty, e.g. request_count, request_duration, request_error_count
func (r ApiGetWorkloadMetricsRequest) Filters(filters string) ApiGetWorkloadMetricsRequest {
	r.filters = &filters
	return r
}

// from which UNIX time to extract metrics
func (r ApiGetWorkloadMetricsRequest) QueryTime(queryTime string) ApiGetWorkloadMetricsRequest {
	r.queryTime = &queryTime
	return r
}

// duration of the query period, in seconds
func (r ApiGetWorkloadMetricsRequest) Duration(duration string) ApiGetWorkloadMetricsRequest {
	r.duration = &duration
	return r
}

// step between graph data points, in seconds.
func (r ApiGetWorkloadMetricsRequest) Step(step string) ApiGetWorkloadMetricsRequest {
	r.step = &step
	return r
}

// metrics rate intervals, e.g. 20s
func (r ApiGetWorkloadMetricsRequest) RateInterval(rateInterval string) ApiGetWorkloadMetricsRequest {
	r.rateInterval = &rateInterval
	return r
}

// traffic direction: &#39;inbound&#39; or &#39;outbound&#39;
func (r ApiGetWorkloadMetricsRequest) Direction(direction string) ApiGetWorkloadMetricsRequest {
	r.direction = &direction
	return r
}

// list of quantiles to fetch, fetch no quantiles when empty. eg. 0.5, 0.9, 0.99
func (r ApiGetWorkloadMetricsRequest) Quantiles(quantiles string) ApiGetWorkloadMetricsRequest {
	r.quantiles = &quantiles
	return r
}

// list of labels to use for grouping metrics(via Prometheus &#39;by&#39; clause), e.g. source_workload, destination_service_name
func (r ApiGetWorkloadMetricsRequest) ByLabels(byLabels string) ApiGetWorkloadMetricsRequest {
	r.byLabels = &byLabels
	return r
}

// request protocol for the telemetry, e.g. http/tcp/grpc
func (r ApiGetWorkloadMetricsRequest) RequestProtocol(requestProtocol string) ApiGetWorkloadMetricsRequest {
	r.requestProtocol = &requestProtocol
	return r
}

// istio telemetry reporter, &#39;source&#39; or &#39;destination&#39;
func (r ApiGetWorkloadMetricsRequest) Reporter(reporter string) ApiGetWorkloadMetricsRequest {
	r.reporter = &reporter
	return r
}

func (r ApiGetWorkloadMetricsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetWorkloadMetricsExecute(r)
}

/*
GetWorkloadMetrics Get workload metrics from a specific namespace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace name of the namespace
 @param workload name of the workload
 @return ApiGetWorkloadMetricsRequest
*/
func (a *ServiceMeshAPIService) GetWorkloadMetrics(ctx context.Context, namespace string, workload string) ApiGetWorkloadMetricsRequest {
	return ApiGetWorkloadMetricsRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
		workload: workload,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ServiceMeshAPIService) GetWorkloadMetricsExecute(r ApiGetWorkloadMetricsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceMeshAPIService.GetWorkloadMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kapis/servicemesh.kubesphere.io/v1alpha2/namespaces/{namespace}/workloads/{workload}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workload"+"}", url.PathEscape(parameterValueToString(r.workload, "workload")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[]", r.filters, "form", "")
	} else {
		var defaultValue string = "[]"
		r.filters = &defaultValue
	}
	if r.queryTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryTime", r.queryTime, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	} else {
		var defaultValue string = "1800"
		r.duration = &defaultValue
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	} else {
		var defaultValue string = "15"
		r.step = &defaultValue
	}
	if r.rateInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rateInterval", r.rateInterval, "form", "")
	} else {
		var defaultValue string = "1m"
		r.rateInterval = &defaultValue
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "form", "")
	} else {
		var defaultValue string = "outbound"
		r.direction = &defaultValue
	}
	if r.quantiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantiles[]", r.quantiles, "form", "")
	} else {
		var defaultValue string = "[]"
		r.quantiles = &defaultValue
	}
	if r.byLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "byLabels[]", r.byLabels, "form", "")
	} else {
		var defaultValue string = "[]"
		r.byLabels = &defaultValue
	}
	if r.requestProtocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestProtocol", r.requestProtocol, "form", "")
	} else {
		var defaultValue string = "all protocols"
		r.requestProtocol = &defaultValue
	}
	if r.reporter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporter", r.reporter, "form", "")
	} else {
		var defaultValue string = "source"
		r.reporter = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
